/* rxjs@7.8.0 */
import{O as e,S as s,o as t,a as r,b as i,V as a,c as n,n as o,e as c,C as h,d as l,f as u,i as d,g as b,t as m,p as f}from"./rxjs-shared.min.js";class p{constructor(e,s=1/0){this.subscribedFrame=e,this.unsubscribedFrame=s}}class w{constructor(){this.subscriptions=[]}logSubscribedFrame(){return this.subscriptions.push(new p(this.scheduler.now())),this.subscriptions.length-1}logUnsubscribedFrame(e){const s=this.subscriptions,t=s[e];s[e]=new p(t.subscribedFrame,this.scheduler.now())}}class g extends e{constructor(e,t){super((function(e){const t=this,r=t.logSubscribedFrame(),i=new s;return i.add(new s((()=>{t.logUnsubscribedFrame(r)}))),t.scheduleMessages(e),i})),this.messages=e,this.subscriptions=[],this.scheduler=t}scheduleMessages(e){const s=this.messages.length;for(let r=0;r<s;r++){const s=this.messages[r];e.add(this.scheduler.schedule((e=>{const{message:{notification:s},subscriber:r}=e;t(s,r)}),s.frame,{message:s,subscriber:e}))}}}r(g,[w]);class v extends i{constructor(e,s){super(),this.messages=e,this.subscriptions=[],this.scheduler=s}_subscribe(e){const t=this,r=t.logSubscribedFrame(),i=new s;return i.add(new s((()=>{t.logUnsubscribedFrame(r)}))),i.add(super._subscribe(e)),i}setup(){const e=this,s=e.messages.length;for(let r=0;r<s;r++)(()=>{const{notification:s,frame:i}=e.messages[r];e.scheduler.schedule((()=>{t(s,e)}),i)})()}}r(v,[w]);class x extends a{constructor(e){super(n,750),this.assertDeepEqual=e,this.hotObservables=[],this.coldObservables=[],this.flushTests=[],this.runMode=!1}createTime(e){const s=this.runMode?e.trim().indexOf("|"):e.indexOf("|");if(-1===s)throw new Error('marble diagram for time should have a completion marker "|"');return s*x.frameTimeFactor}createColdObservable(e,s,t){if(-1!==e.indexOf("^"))throw new Error('cold observable cannot have subscription offset "^"');if(-1!==e.indexOf("!"))throw new Error('cold observable cannot have unsubscription marker "!"');const r=x.parseMarbles(e,s,t,void 0,this.runMode),i=new g(r,this);return this.coldObservables.push(i),i}createHotObservable(e,s,t){if(-1!==e.indexOf("!"))throw new Error('hot observable cannot have unsubscription marker "!"');const r=x.parseMarbles(e,s,t,void 0,this.runMode),i=new v(r,this);return this.hotObservables.push(i),i}materializeInnerObservable(e,s){const t=[];return e.subscribe({next:e=>{t.push({frame:this.frame-s,notification:o(e)})},error:e=>{t.push({frame:this.frame-s,notification:c(e)})},complete:()=>{t.push({frame:this.frame-s,notification:h})}}),t}expectObservable(s,t=null){const r=[],i={actual:r,ready:!1},a=x.parseMarblesAsSubscriptions(t,this.runMode),n=a.subscribedFrame===1/0?0:a.subscribedFrame,l=a.unsubscribedFrame;let u;this.schedule((()=>{u=s.subscribe({next:s=>{const t=s instanceof e?this.materializeInnerObservable(s,this.frame):s;r.push({frame:this.frame,notification:o(t)})},error:e=>{r.push({frame:this.frame,notification:c(e)})},complete:()=>{r.push({frame:this.frame,notification:h})}})}),n),l!==1/0&&this.schedule((()=>u.unsubscribe()),l),this.flushTests.push(i);const{runMode:d}=this;return{toBe(e,s,t){i.ready=!0,i.expected=x.parseMarbles(e,s,t,!0,d)},toEqual:s=>{i.ready=!0,i.expected=[],this.schedule((()=>{u=s.subscribe({next:s=>{const t=s instanceof e?this.materializeInnerObservable(s,this.frame):s;i.expected.push({frame:this.frame,notification:o(t)})},error:e=>{i.expected.push({frame:this.frame,notification:c(e)})},complete:()=>{i.expected.push({frame:this.frame,notification:h})}})}),n)}}}expectSubscriptions(e){const s={actual:e,ready:!1};this.flushTests.push(s);const{runMode:t}=this;return{toBe(e){const r="string"==typeof e?[e]:e;s.ready=!0,s.expected=r.map((e=>x.parseMarblesAsSubscriptions(e,t))).filter((e=>e.subscribedFrame!==1/0))}}}flush(){const e=this.hotObservables;for(;e.length>0;)e.shift().setup();super.flush(),this.flushTests=this.flushTests.filter((e=>!e.ready||(this.assertDeepEqual(e.actual,e.expected),!1)))}static parseMarblesAsSubscriptions(e,s=!1){if("string"!=typeof e)return new p(1/0);const t=[...e],r=t.length;let i=-1,a=1/0,n=1/0,o=0;for(let e=0;e<r;e++){let r=o;const c=e=>{r+=e*this.frameTimeFactor},h=t[e];switch(h){case" ":s||c(1);break;case"-":c(1);break;case"(":i=o,c(1);break;case")":i=-1,c(1);break;case"^":if(a!==1/0)throw new Error("found a second subscription point '^' in a subscription marble diagram. There can only be one.");a=i>-1?i:o,c(1);break;case"!":if(n!==1/0)throw new Error("found a second unsubscription point '!' in a subscription marble diagram. There can only be one.");n=i>-1?i:o;break;default:if(s&&h.match(/^[0-9]$/)&&(0===e||" "===t[e-1])){const s=t.slice(e).join("").match(/^([0-9]+(?:\.[0-9]+)?)(ms|s|m) /);if(s){e+=s[0].length-1;const t=parseFloat(s[1]);let r;switch(s[2]){case"ms":r=t;break;case"s":r=1e3*t;break;case"m":r=1e3*t*60}c(r/this.frameTimeFactor);break}}throw new Error("there can only be '^' and '!' markers in a subscription marble diagram. Found instead '"+h+"'.")}o=r}return n<0?new p(a):new p(a,n)}static parseMarbles(e,s,t,r=!1,i=!1){if(-1!==e.indexOf("!"))throw new Error('conventional marble diagrams cannot have the unsubscription marker "!"');const a=[...e],n=a.length,l=[],u=i?e.replace(/^[ ]+/,"").indexOf("^"):e.indexOf("^");let d=-1===u?0:u*-this.frameTimeFactor;const b="object"!=typeof s?e=>e:e=>r&&s[e]instanceof g?s[e].messages:s[e];let m=-1;for(let e=0;e<n;e++){let s=d;const r=e=>{s+=e*this.frameTimeFactor};let n;const u=a[e];switch(u){case" ":i||r(1);break;case"-":r(1);break;case"(":m=d,r(1);break;case")":m=-1,r(1);break;case"|":n=h,r(1);break;case"^":r(1);break;case"#":n=c(t||"error"),r(1);break;default:if(i&&u.match(/^[0-9]$/)&&(0===e||" "===a[e-1])){const s=a.slice(e).join("").match(/^([0-9]+(?:\.[0-9]+)?)(ms|s|m) /);if(s){e+=s[0].length-1;const t=parseFloat(s[1]);let i;switch(s[2]){case"ms":i=t;break;case"s":i=1e3*t;break;case"m":i=1e3*t*60}r(i/this.frameTimeFactor);break}}n=o(b(u)),r(1)}n&&l.push({frame:m>-1?m:d,notification:n}),d=s}return l}createAnimator(){if(!this.runMode)throw new Error("animate() must only be used in run mode");let e,s=0;return{animate:s=>{if(e)throw new Error("animate() must not be called more than once within run()");if(/[|#]/.test(s))throw new Error("animate() must not complete or error");e=new Map;const t=x.parseMarbles(s,void 0,void 0,void 0,!0);for(const s of t)this.schedule((()=>{const s=this.now(),t=Array.from(e.values());e.clear();for(const e of t)e(s)}),s.frame)},delegate:{requestAnimationFrame(t){if(!e)throw new Error("animate() was not called within run()");const r=++s;return e.set(r,t),r},cancelAnimationFrame(s){if(!e)throw new Error("animate() was not called within run()");e.delete(s)}}}}createDelegates(){let e=0;const s=new Map,t=()=>{const e=this.now(),r=Array.from(s.values()).filter((({due:s})=>s<=e)),i=r.filter((({type:e})=>"immediate"===e));if(i.length>0){const{handle:e,handler:t}=i[0];return s.delete(e),void t()}const a=r.filter((({type:e})=>"interval"===e));if(a.length>0){const s=a[0],{duration:r,handler:i}=s;return s.due=e+r,s.subscription=this.schedule(t,r),void i()}const n=r.filter((({type:e})=>"timeout"===e));if(n.length>0){const{handle:e,handler:t}=n[0];return s.delete(e),void t()}throw new Error("Expected a due immediate or interval")};return{immediate:{setImmediate:r=>{const i=++e;return s.set(i,{due:this.now(),duration:0,handle:i,handler:r,subscription:this.schedule(t,0),type:"immediate"}),i},clearImmediate:e=>{const t=s.get(e);t&&(t.subscription.unsubscribe(),s.delete(e))}},interval:{setInterval:(r,i=0)=>{const a=++e;return s.set(a,{due:this.now()+i,duration:i,handle:a,handler:r,subscription:this.schedule(t,i),type:"interval"}),a},clearInterval:e=>{const t=s.get(e);t&&(t.subscription.unsubscribe(),s.delete(e))}},timeout:{setTimeout:(r,i=0)=>{const a=++e;return s.set(a,{due:this.now()+i,duration:i,handle:a,handler:r,subscription:this.schedule(t,i),type:"timeout"}),a},clearTimeout:e=>{const t=s.get(e);t&&(t.subscription.unsubscribe(),s.delete(e))}}}}run(e){const s=x.frameTimeFactor,t=this.maxFrames;x.frameTimeFactor=1,this.maxFrames=1/0,this.runMode=!0;const r=this.createAnimator(),i=this.createDelegates();l.delegate=r.delegate,u.delegate=this,d.delegate=i.immediate,b.delegate=i.interval,m.delegate=i.timeout,f.delegate=this;const a={cold:this.createColdObservable.bind(this),hot:this.createHotObservable.bind(this),flush:this.flush.bind(this),time:this.createTime.bind(this),expectObservable:this.expectObservable.bind(this),expectSubscriptions:this.expectSubscriptions.bind(this),animate:r.animate};try{const r=e(a);return this.flush(),r}finally{x.frameTimeFactor=s,this.maxFrames=t,this.runMode=!1,l.delegate=void 0,u.delegate=void 0,d.delegate=void 0,b.delegate=void 0,m.delegate=void 0,f.delegate=void 0}}}x.frameTimeFactor=10;export{x as T};
