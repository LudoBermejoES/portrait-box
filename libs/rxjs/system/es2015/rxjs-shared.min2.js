/* rxjs@7.8.0 */
System.register(["./rxjs-shared.min.js"],(function(e){"use strict";var t,s,r,i,a,n,o,c,h,u,l,d,b,m,f,p;return{setters:[function(e){t=e.O,s=e.S,r=e.o,i=e.a,a=e.b,n=e.V,o=e.c,c=e.n,h=e.e,u=e.C,l=e.d,d=e.f,b=e.i,m=e.g,f=e.t,p=e.p}],execute:function(){class w{constructor(e,t=1/0){this.subscribedFrame=e,this.unsubscribedFrame=t}}class g{constructor(){this.subscriptions=[]}logSubscribedFrame(){return this.subscriptions.push(new w(this.scheduler.now())),this.subscriptions.length-1}logUnsubscribedFrame(e){const t=this.subscriptions,s=t[e];t[e]=new w(s.subscribedFrame,this.scheduler.now())}}class v extends t{constructor(e,t){super((function(e){const t=this,r=t.logSubscribedFrame(),i=new s;return i.add(new s((()=>{t.logUnsubscribedFrame(r)}))),t.scheduleMessages(e),i})),this.messages=e,this.subscriptions=[],this.scheduler=t}scheduleMessages(e){const t=this.messages.length;for(let s=0;s<t;s++){const t=this.messages[s];e.add(this.scheduler.schedule((e=>{const{message:{notification:t},subscriber:s}=e;r(t,s)}),t.frame,{message:t,subscriber:e}))}}}i(v,[g]);class x extends a{constructor(e,t){super(),this.messages=e,this.subscriptions=[],this.scheduler=t}_subscribe(e){const t=this,r=t.logSubscribedFrame(),i=new s;return i.add(new s((()=>{t.logUnsubscribedFrame(r)}))),i.add(super._subscribe(e)),i}setup(){const e=this,t=e.messages.length;for(let s=0;s<t;s++)(()=>{const{notification:t,frame:i}=e.messages[s];e.scheduler.schedule((()=>{r(t,e)}),i)})()}}i(x,[g]);class F extends n{constructor(e){super(o,750),this.assertDeepEqual=e,this.hotObservables=[],this.coldObservables=[],this.flushTests=[],this.runMode=!1}createTime(e){const t=this.runMode?e.trim().indexOf("|"):e.indexOf("|");if(-1===t)throw new Error('marble diagram for time should have a completion marker "|"');return t*F.frameTimeFactor}createColdObservable(e,t,s){if(-1!==e.indexOf("^"))throw new Error('cold observable cannot have subscription offset "^"');if(-1!==e.indexOf("!"))throw new Error('cold observable cannot have unsubscription marker "!"');const r=F.parseMarbles(e,t,s,void 0,this.runMode),i=new v(r,this);return this.coldObservables.push(i),i}createHotObservable(e,t,s){if(-1!==e.indexOf("!"))throw new Error('hot observable cannot have unsubscription marker "!"');const r=F.parseMarbles(e,t,s,void 0,this.runMode),i=new x(r,this);return this.hotObservables.push(i),i}materializeInnerObservable(e,t){const s=[];return e.subscribe({next:e=>{s.push({frame:this.frame-t,notification:c(e)})},error:e=>{s.push({frame:this.frame-t,notification:h(e)})},complete:()=>{s.push({frame:this.frame-t,notification:u})}}),s}expectObservable(e,s=null){const r=[],i={actual:r,ready:!1},a=F.parseMarblesAsSubscriptions(s,this.runMode),n=a.subscribedFrame===1/0?0:a.subscribedFrame,o=a.unsubscribedFrame;let l;this.schedule((()=>{l=e.subscribe({next:e=>{const s=e instanceof t?this.materializeInnerObservable(e,this.frame):e;r.push({frame:this.frame,notification:c(s)})},error:e=>{r.push({frame:this.frame,notification:h(e)})},complete:()=>{r.push({frame:this.frame,notification:u})}})}),n),o!==1/0&&this.schedule((()=>l.unsubscribe()),o),this.flushTests.push(i);const{runMode:d}=this;return{toBe(e,t,s){i.ready=!0,i.expected=F.parseMarbles(e,t,s,!0,d)},toEqual:e=>{i.ready=!0,i.expected=[],this.schedule((()=>{l=e.subscribe({next:e=>{const s=e instanceof t?this.materializeInnerObservable(e,this.frame):e;i.expected.push({frame:this.frame,notification:c(s)})},error:e=>{i.expected.push({frame:this.frame,notification:h(e)})},complete:()=>{i.expected.push({frame:this.frame,notification:u})}})}),n)}}}expectSubscriptions(e){const t={actual:e,ready:!1};this.flushTests.push(t);const{runMode:s}=this;return{toBe(e){const r="string"==typeof e?[e]:e;t.ready=!0,t.expected=r.map((e=>F.parseMarblesAsSubscriptions(e,s))).filter((e=>e.subscribedFrame!==1/0))}}}flush(){const e=this.hotObservables;for(;e.length>0;)e.shift().setup();super.flush(),this.flushTests=this.flushTests.filter((e=>!e.ready||(this.assertDeepEqual(e.actual,e.expected),!1)))}static parseMarblesAsSubscriptions(e,t=!1){if("string"!=typeof e)return new w(1/0);const s=[...e],r=s.length;let i=-1,a=1/0,n=1/0,o=0;for(let e=0;e<r;e++){let r=o;const c=e=>{r+=e*this.frameTimeFactor},h=s[e];switch(h){case" ":t||c(1);break;case"-":c(1);break;case"(":i=o,c(1);break;case")":i=-1,c(1);break;case"^":if(a!==1/0)throw new Error("found a second subscription point '^' in a subscription marble diagram. There can only be one.");a=i>-1?i:o,c(1);break;case"!":if(n!==1/0)throw new Error("found a second unsubscription point '!' in a subscription marble diagram. There can only be one.");n=i>-1?i:o;break;default:if(t&&h.match(/^[0-9]$/)&&(0===e||" "===s[e-1])){const t=s.slice(e).join("").match(/^([0-9]+(?:\.[0-9]+)?)(ms|s|m) /);if(t){e+=t[0].length-1;const s=parseFloat(t[1]);let r;switch(t[2]){case"ms":r=s;break;case"s":r=1e3*s;break;case"m":r=1e3*s*60}c(r/this.frameTimeFactor);break}}throw new Error("there can only be '^' and '!' markers in a subscription marble diagram. Found instead '"+h+"'.")}o=r}return n<0?new w(a):new w(a,n)}static parseMarbles(e,t,s,r=!1,i=!1){if(-1!==e.indexOf("!"))throw new Error('conventional marble diagrams cannot have the unsubscription marker "!"');const a=[...e],n=a.length,o=[],l=i?e.replace(/^[ ]+/,"").indexOf("^"):e.indexOf("^");let d=-1===l?0:l*-this.frameTimeFactor;const b="object"!=typeof t?e=>e:e=>r&&t[e]instanceof v?t[e].messages:t[e];let m=-1;for(let e=0;e<n;e++){let t=d;const r=e=>{t+=e*this.frameTimeFactor};let n;const l=a[e];switch(l){case" ":i||r(1);break;case"-":r(1);break;case"(":m=d,r(1);break;case")":m=-1,r(1);break;case"|":n=u,r(1);break;case"^":r(1);break;case"#":n=h(s||"error"),r(1);break;default:if(i&&l.match(/^[0-9]$/)&&(0===e||" "===a[e-1])){const t=a.slice(e).join("").match(/^([0-9]+(?:\.[0-9]+)?)(ms|s|m) /);if(t){e+=t[0].length-1;const s=parseFloat(t[1]);let i;switch(t[2]){case"ms":i=s;break;case"s":i=1e3*s;break;case"m":i=1e3*s*60}r(i/this.frameTimeFactor);break}}n=c(b(l)),r(1)}n&&o.push({frame:m>-1?m:d,notification:n}),d=t}return o}createAnimator(){if(!this.runMode)throw new Error("animate() must only be used in run mode");let e,t=0;return{animate:t=>{if(e)throw new Error("animate() must not be called more than once within run()");if(/[|#]/.test(t))throw new Error("animate() must not complete or error");e=new Map;const s=F.parseMarbles(t,void 0,void 0,void 0,!0);for(const t of s)this.schedule((()=>{const t=this.now(),s=Array.from(e.values());e.clear();for(const e of s)e(t)}),t.frame)},delegate:{requestAnimationFrame(s){if(!e)throw new Error("animate() was not called within run()");const r=++t;return e.set(r,s),r},cancelAnimationFrame(t){if(!e)throw new Error("animate() was not called within run()");e.delete(t)}}}}createDelegates(){let e=0;const t=new Map,s=()=>{const e=this.now(),r=Array.from(t.values()).filter((({due:t})=>t<=e)),i=r.filter((({type:e})=>"immediate"===e));if(i.length>0){const{handle:e,handler:s}=i[0];return t.delete(e),void s()}const a=r.filter((({type:e})=>"interval"===e));if(a.length>0){const t=a[0],{duration:r,handler:i}=t;return t.due=e+r,t.subscription=this.schedule(s,r),void i()}const n=r.filter((({type:e})=>"timeout"===e));if(n.length>0){const{handle:e,handler:s}=n[0];return t.delete(e),void s()}throw new Error("Expected a due immediate or interval")};return{immediate:{setImmediate:r=>{const i=++e;return t.set(i,{due:this.now(),duration:0,handle:i,handler:r,subscription:this.schedule(s,0),type:"immediate"}),i},clearImmediate:e=>{const s=t.get(e);s&&(s.subscription.unsubscribe(),t.delete(e))}},interval:{setInterval:(r,i=0)=>{const a=++e;return t.set(a,{due:this.now()+i,duration:i,handle:a,handler:r,subscription:this.schedule(s,i),type:"interval"}),a},clearInterval:e=>{const s=t.get(e);s&&(s.subscription.unsubscribe(),t.delete(e))}},timeout:{setTimeout:(r,i=0)=>{const a=++e;return t.set(a,{due:this.now()+i,duration:i,handle:a,handler:r,subscription:this.schedule(s,i),type:"timeout"}),a},clearTimeout:e=>{const s=t.get(e);s&&(s.subscription.unsubscribe(),t.delete(e))}}}}run(e){const t=F.frameTimeFactor,s=this.maxFrames;F.frameTimeFactor=1,this.maxFrames=1/0,this.runMode=!0;const r=this.createAnimator(),i=this.createDelegates();l.delegate=r.delegate,d.delegate=this,b.delegate=i.immediate,m.delegate=i.interval,f.delegate=i.timeout,p.delegate=this;const a={cold:this.createColdObservable.bind(this),hot:this.createHotObservable.bind(this),flush:this.flush.bind(this),time:this.createTime.bind(this),expectObservable:this.expectObservable.bind(this),expectSubscriptions:this.expectSubscriptions.bind(this),animate:r.animate};try{const r=e(a);return this.flush(),r}finally{F.frameTimeFactor=t,this.maxFrames=s,this.runMode=!1,l.delegate=void 0,d.delegate=void 0,b.delegate=void 0,m.delegate=void 0,f.delegate=void 0,p.delegate=void 0}}}e("T",F),F.frameTimeFactor=10}}}));
